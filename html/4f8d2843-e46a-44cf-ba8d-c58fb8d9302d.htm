<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Shadow Maps</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="4f8d2843-e46a-44cf-ba8d-c58fb8d9302d" /><meta name="Description" content="This article covers how shadow maps are created." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script><link rel="stylesheet" type="text/css" href="../styles/branding-Website.css" /><script type="text/javascript" src="../scripts/jquery-1.11.0.min.js"></script><script type="text/javascript" src="../scripts/branding-Website.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">DigitalRune Documentation<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="38bd0f53-477c-48c5-91cc-b9fb7062ceb3.htm" title="DigitalRune Documentation" tocid="roottoc">DigitalRune Documentation</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="0a8eb9ca-74ae-4746-9289-93d909b07e22.htm" title="DigitalRune Graphics" tocid="0a8eb9ca-74ae-4746-9289-93d909b07e22">DigitalRune Graphics</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="7d5a0abe-8231-452c-895c-e6dbab83822b.htm" title="Graphics Programming" tocid="7d5a0abe-8231-452c-895c-e6dbab83822b">Graphics Programming</a></div><div class="toclevel1" data-toclevel="1" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="3f82c46b-efec-4416-807f-670ac1930117.htm" title="Shadows" tocid="3f82c46b-efec-4416-807f-670ac1930117">Shadows</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="8666619e-60d7-436e-8a0f-b3d982f0dca7.htm" title="Shadow Types" tocid="8666619e-60d7-436e-8a0f-b3d982f0dca7">Shadow Types</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="bed07eb7-0d10-40f3-93e8-c823a787b6a7.htm" title="Shadow Filtering" tocid="bed07eb7-0d10-40f3-93e8-c823a787b6a7">Shadow Filtering</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="3f4d959e-9c98-4a97-8d85-7a73c26145d7.htm" title="Shadow Acne" tocid="3f4d959e-9c98-4a97-8d85-7a73c26145d7">Shadow Acne</a></div><div class="toclevel2 current" data-toclevel="2"><a data-tochassubtree="false" href="4f8d2843-e46a-44cf-ba8d-c58fb8d9302d.htm" title="Shadow Maps" tocid="4f8d2843-e46a-44cf-ba8d-c58fb8d9302d">Shadow Maps</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="a3f49f80-226e-4a6b-b13a-dbf673b41438.htm" title="Shadow Masks" tocid="a3f49f80-226e-4a6b-b13a-dbf673b41438">Shadow Masks</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="../icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="../icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="logoColumn"><img alt="DigitalRune" src="../icons/DigitalRune-Logo.png" /></td><td class="titleColumn">Shadow Maps</td></tr></table><span class="introStyle"></span><div class="introduction"><p>This article covers how shadow maps are created.</p><p>This topic contains the following sections:</p><ul class="autoOutline"><li class="outlineSectionEntry"><a href="#ShadowMapRenderer">ShadowMapRenderer</a></li><li class="outlineSectionEntry"><a href="#Types">Shadow map types</a></li><li class="outlineSectionEntry"><a href="#Callback">Render callback</a></li><li class="outlineSectionEntry"><a href="#Shaders">Shadow map shaders</a></li><li class="outlineSectionEntry"><a href="#Caching">Shadow map caching</a></li><li class="outlineSectionEntry"><a href="#Recycling">Recycling shadow maps</a></li></ul></div><div class="collapsibleAreaRegion" id="ShadowMapRenderer"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />ShadowMapRenderer</span></div><div id="ID1RBSection" class="collapsibleSection"><p>
                    DigitalRune Graphics provides the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>
                    for creating shadow maps.
                </p><p>
                    Shadow maps are created by calling
                    <a href="6eac504d-c05e-e683-324e-7a253f862a8b.htm">Render</a>.
                    For example:
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EACAGAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EACAGAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EACAGAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EACAGAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-comment">// Select render pass (required by MeshRenderer).</span>
context.RenderPass = <span class="highlight-literal">"ShadowMap"</span>;
<span class="highlight-comment">// Render shadow maps for the specified list of light nodes.</span>
shadowMapRenderer.Render(sceneNodes, context);</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EACAGAAA");</script><p>
                    The
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>
                    takes a list of scene nodes and looks for
                    <a href="100df524-cf31-0d95-6828-c31c838355cd.htm">LightNode</a>s
                    with a
                    <a href="2571af11-e755-707d-db01-1cd25fcd5ebd.htm">Shadow</a>.
                    <a href="100df524-cf31-0d95-6828-c31c838355cd.htm">LightNode</a>s
                    are sorted based on the shadow map type. Then the shadow maps are rendered: For each
                    shadow map, the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>
                    prepares a render target and sets the required states. It fetches all shadow casters
                    (meshes, etc.) and renders them into the render target. The resulting shadow maps are
                    stored in
                    <a href="80b7e21d-3481-58ca-2b2c-061241ac6da0.htm">Shadow<span id="LST27581369_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_0?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>ShadowMap</a>.
                </p><p>
                    This method is usually called once per frame – but it is also possible to reuse shadow
                    maps from previous frames (see
                    <span class="term">Shadow Map Caching</span>
                    below).
                </p></div><div class="collapsibleAreaRegion" id="Types"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID2RB')" onkeypress="SectionExpandCollapse_CheckKey('ID2RB', event)" tabindex="0"><img id="ID2RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Shadow map types</span></div><div id="ID2RBSection" class="collapsibleSection"><p>
                    The built-in renderer supports
                    <a href="8304ef95-b8af-395c-e56a-035d0d281f97.htm">StandardShadow</a>s,
                    <a href="1ead4eb1-24a9-1697-c981-9b95b1eb9d99.htm">CubeMapShadow</a>s,
                    <a href="0c57c848-9e69-7c24-6357-9798a7a94cbc.htm">CascadedShadow</a>s and
                    <a href="582377bf-1bcc-fea1-d054-f2361884e4ea.htm">CompositeShadow</a>s.
                    Support for other shadow types can be added by implementing a new renderer and adding
                    it to the
                    <a href="b19ae327-741d-5d93-b76f-5cec7929d6aa.htm">Renderers</a>
                    collection of the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>.
                    (See <span class="term">VarianceShadowMapSample</span> in the
                    <a href="dde51686-4f07-4c54-95d4-756ec929cb57.htm">Samples</a>.)
                </p></div><div class="collapsibleAreaRegion" id="Callback"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Render callback</span></div><div id="ID3RBSection" class="collapsibleSection"><p>
                    The
                    <a href="55a54997-3552-3303-47ae-a8344bc216a4.htm">ShadowMapRenderer<span id="LST27581369_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_1?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>RenderCallback</a>
                    can be used to define which shadows casters are selected and how they are rendered. If
                    no render callback is set, a default implementation will be used.
                </p><p>
                    The callback can be set when the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>
                    is created. Here is an example (similar to the default implementation):
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EAEAEAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EAEAEAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EAEAEAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAEAEAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">meshRenderer = <span class="highlight-keyword">new</span> MeshRenderer();
shadowMapRenderer = <span class="highlight-keyword">new</span> ShadowMapRenderer(context =&gt;
{
  <span class="highlight-keyword">var</span> query = context.Scene.Query&lt;ShadowCasterQuery&gt;(context.CameraNode, context);
  <span class="highlight-keyword">if</span> (query.ShadowCasters.Count == <span class="highlight-number">0</span>)
    <span class="highlight-keyword">return</span> <span class="highlight-keyword">false</span>;

  meshRenderer.Render(query.ShadowCasters, context);
  <span class="highlight-keyword">return</span> <span class="highlight-keyword">true</span>;
});</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAEAEAAA");</script><p>
                    In this implementation
                    <a href="2eab84ca-820f-8f41-20b3-fea0a69bd21c.htm">Scene<span id="LST27581369_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_2?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>Query<span id="LST27581369_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_3?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>T<span id="LST27581369_4"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_4?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script></a>
                    is called to get all scene nodes that intersect the camera frustum. (Note: When the
                    render callback is executed,
                    <a href="324769e9-33d4-bc99-cf3a-671dd7715d2f.htm">RenderContext<span id="LST27581369_5"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_5?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>CameraNode</a>
                    is a camera representing the light source and not the player.)
                </p><p>
                    The
                    <a href="b128b7ca-72bc-2c14-c91c-5bb56232ce21.htm">ShadowCasterQuery</a>
                    checks the scene node flags
                    <a href="6742fd55-f5d2-0c37-1128-b4de73746260.htm">SceneNode<span id="LST27581369_6"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_6?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>CastsShadows</a>
                    and
                    <a href="460530b8-1179-f7e5-06cb-c96526b9605f.htm">SceneNode<span id="LST27581369_7"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_7?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>IsShadowCasterCulled</a>.
                    <a href="6742fd55-f5d2-0c37-1128-b4de73746260.htm">CastsShadows</a>
                    determines whether a scene node can cast any shadows.
                    <a href="460530b8-1179-f7e5-06cb-c96526b9605f.htm">IsShadowCasterCulled</a>
                    might be set when occlusion culling is enabled. It indicates whether the shadow is
                    visible from the player's point of view or whether the shadow is occluded. The
                    <a href="b128b7ca-72bc-2c14-c91c-5bb56232ce21.htm">ShadowCasterQuery</a>
                    also evaluates LOD nodes.
                </p><p>
                    Then a
                    <a href="1782e7fc-9a12-dd2d-d73d-8396a786fdeb.htm">MeshRenderer</a>
                    is used to render the shadow casters into the shadow map.
                </p><p>
                    A user-defined render callback can use a different method to select shadow casters and can
                    use other renderers to draw objects into the shadow map.
                </p></div><div class="collapsibleAreaRegion" id="Shaders"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Shadow map shaders</span></div><div id="ID4RBSection" class="collapsibleSection"><p>
                    In the first examples the
                    <a href="79b56643-429a-7edb-f845-391210e21cd8.htm">RenderPass</a>
                    is set to
                    "ShadowMap"
                    before
                    <a href="6eac504d-c05e-e683-324e-7a253f862a8b.htm">Render</a>
                    of the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>
                    is called. That means, the
                    <a href="1782e7fc-9a12-dd2d-d73d-8396a786fdeb.htm">MeshRenderer</a>
                    in the render callback uses the
                    "ShadowMap"
                    pass to render meshes into the shadow map. This render pass must be present in the
                    material (.drmat file) of the mesh, for example:
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EAEADAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EAEADAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAEADAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-xml-bracket">&lt;?</span><span class="highlight-xml-tag">xml</span> <span class="highlight-xml-attribute-name">version</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"1.0"</span> <span class="highlight-xml-attribute-name">encoding</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"utf-8"</span><span class="highlight-xml-bracket">?&gt;</span>
<span class="highlight-xml-bracket">&lt;</span><span class="highlight-xml-tag">Material</span><span class="highlight-xml-bracket">&gt;</span>
  <span class="highlight-xml-bracket">&lt;</span><span class="highlight-xml-tag">Pass</span> <span class="highlight-xml-attribute-name">Name</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"Default"</span> <span class="highlight-xml-attribute-name">Effect</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"SkinnedEffect"</span> <span class="highlight-xml-attribute-name">Profile</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"Any"</span><span class="highlight-xml-bracket">&gt;</span>
    …
  <span class="highlight-xml-bracket">&lt;/</span><span class="highlight-xml-tag">Pass</span><span class="highlight-xml-bracket">&gt;</span>

  <span class="highlight-xml-comment">&lt;!-- Render pass which renders a mesh into a shadow map. --&gt;</span>
  <span class="highlight-xml-bracket">&lt;</span><span class="highlight-xml-tag">Pass</span> <span class="highlight-xml-attribute-name">Name</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"ShadowMap"</span> <span class="highlight-xml-attribute-name">Effect</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"DigitalRune/Materials/ShadowMapSkinned"</span> <span class="highlight-xml-attribute-name">Profile</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"HiDef"</span> <span class="highlight-xml-bracket">/&gt;</span> 

  <span class="highlight-xml-bracket">&lt;</span><span class="highlight-xml-tag">Pass</span> <span class="highlight-xml-attribute-name">Name</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"GBuffer"</span> <span class="highlight-xml-attribute-name">Effect</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"DigitalRune/Materials/GBufferNormalSkinned"</span> <span class="highlight-xml-attribute-name">Profile</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"HiDef"</span><span class="highlight-xml-bracket">&gt;</span>
    …
  <span class="highlight-xml-bracket">&lt;/</span><span class="highlight-xml-tag">Pass</span><span class="highlight-xml-bracket">&gt;</span>
  <span class="highlight-xml-bracket">&lt;</span><span class="highlight-xml-tag">Pass</span> <span class="highlight-xml-attribute-name">Name</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"Material"</span> <span class="highlight-xml-attribute-name">Effect</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"DigitalRune/Materials/MaterialSkinned"</span> <span class="highlight-xml-attribute-name">Profile</span><span class="highlight-xml-attribute-equal">=</span><span class="highlight-xml-attribute-value">"HiDef"</span><span class="highlight-xml-bracket">&gt;</span>
    …
  <span class="highlight-xml-bracket">&lt;/</span><span class="highlight-xml-tag">Pass</span><span class="highlight-xml-bracket">&gt;</span>
<span class="highlight-xml-bracket">&lt;/</span><span class="highlight-xml-tag">Material</span><span class="highlight-xml-bracket">&gt;</span></pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAEADAAA");</script><p>
                    Meshes without a "ShadowMap" pass will be ignored and won't be rendered into the shadow
                    map. DigitalRune Graphics contains several predefined effects for rendering shadow maps,
                    supporting alpha-tests, mesh skinning and morphing.
                </p><p>
                    The depth that is written to the shadow map is the normalized light space z value (=
                    distance to the shadow near plane) – except for omnidirectional shadow maps of point lights,
                    where the depth value is the normalized linear distance to the point light. For cascaded
                    shadow maps triangles in front of the cascade are clamped to 0 to make better use of the
                    available depth map precision. This is called "pancaking". When using pancaking we found
                    that 16-bit shadow maps are usually enough. (The property
                    <a href="f24a0f19-851b-93f1-6678-833327dc4c3b.htm">Shadow<span id="LST27581369_8"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_8?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>Prefer16Bit</a>
                    is set by default.)
                </p><p>
                    The "ShadowMap" effects (.fx files) define whether front faces (= triangles facing the
                    light source) or back faces are rendered into the shadow map. The predefined
                    "ShadowMap" effects render front faces.
                </p><p>
                    Some games render back faces, which has the advantage of moving shadow acne problems to
                    the back of a mesh. Back faces are usually not facing the light, hence they are dark and
                    acne is less of a problem. When rendering back faces, shadow bias values must be negative.
                    Avoiding shadow acne by rendering back faces does not work for thin meshes, such as
                    alpha-tested grass. (In the end, we did not find any relevant benefits of rendering back
                    faces and chose to render front faces as the default.)
                </p></div><div class="collapsibleAreaRegion" id="Caching"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID5RB')" onkeypress="SectionExpandCollapse_CheckKey('ID5RB', event)" tabindex="0"><img id="ID5RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Shadow map caching</span></div><div id="ID5RBSection" class="collapsibleSection"><p>
                    The
                    <a href="2571af11-e755-707d-db01-1cd25fcd5ebd.htm">Shadow</a>
                    class stores the shadow map (property
                    <a href="80b7e21d-3481-58ca-2b2c-061241ac6da0.htm">ShadowMap</a>)
                    and all necessary information (e.g. the light's view and projection matrix) for reuse in
                    the next frame. That means, it is not necessary to update all shadow maps every frame.
                </p><p>
                    Further, the flag
                    <a href="06747a6f-bb13-ac14-b4bf-d337f5753135.htm">CascadedShadow<span id="LST27581369_9"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST27581369_9?cs=.|vb=.|cpp=::|nu=.|fs=.");</script>IsCascadeLocked</a>
                    can be used to "lock" individual cascades of a cascaded shadow map. Locked cascades will
                    not be updated by the
                    <a href="50fe6abc-deec-f38d-d866-9d6558a2ebdf.htm">ShadowMapRenderer</a>,
                    the cached shadow map will be reused until the cascade is unlocked.
                </p><p>
                    Shadow map caching can be used to improve performance. For example:
                </p><ul><li>
                        Reuse shadow maps from the previous frames if there are no moving objects in the light.
                    </li><li>
                        Update shadow maps of distant lights less frequently.
                    </li><li>
                        Update distant cascades less frequently.
                    </li><li>
                        Do not update all shadow maps in the same frame. Distribute the update of different
                        shadow maps or cascades over several frames.
                    </li></ul></div><div class="collapsibleAreaRegion" id="Recycling"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID6RB')" onkeypress="SectionExpandCollapse_CheckKey('ID6RB', event)" tabindex="0"><img id="ID6RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Recycling shadow maps</span></div><div id="ID6RBSection" class="collapsibleSection"><p>
                    To support shadow map caching, shadow maps are not recycled automatically. When the
                    shadow maps are no longer required, they must be recycled manually:
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EADABAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EADABAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EADABAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EADABAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">foreach</span> (<span class="highlight-keyword">var</span> node <span class="highlight-keyword">in</span> sceneNodes)
{
  <span class="highlight-keyword">var</span> lightNode = node <span class="highlight-keyword">as</span> LightNode;
  <span class="highlight-keyword">if</span> (lightNode != <span class="highlight-keyword">null</span> &amp;&amp; lightNode.Shadow != <span class="highlight-keyword">null</span>)
  {
    renderTargetPool.Recycle(lightNode.Shadow.ShadowMap);
    lightNode.Shadow.ShadowMap = <span class="highlight-keyword">null</span>;
  }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EADABAAA");</script><p>
                    If a
                    <a href="582377bf-1bcc-fea1-d054-f2361884e4ea.htm">CompositeShadow</a>
                    is used, you have to enumerate the child shadows:
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EABABAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EABABAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EABABAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EABABAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">if</span> (shadow <span class="highlight-keyword">is</span> CompositeShadow)
    <span class="highlight-keyword">foreach</span>(<span class="highlight-keyword">var</span> child <span class="highlight-keyword">in</span> shadow.Shadows)
      … recycle shadow map …</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EABABAAA");</script><p>
                    When shadow map caching is not used, it is usually best to recycle the shadow maps each
                    frame as soon as they are no longer needed.
                </p></div></div></div><div id="pageFooter" class="pageFooter">Copyright (c) 2006-2016 DigitalRune GmbH. All rights reserved. (Last updated: 2016-03-10)<p><a href="http://www.digitalrune.com/" target="_blank">http://www.digitalrune.com/</a></p><div class="feedbackLink">Send comments on this topic to
        <a id="HT_MailLink" href="mailto:office%40digitalrune.com?Subject=DigitalRune Documentation">office@digitalrune.com</a></div><script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script></div></body></html>